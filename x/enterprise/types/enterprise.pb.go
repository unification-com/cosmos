// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: mainchain/enterprise/v1/enterprise.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// PurchaseOrderStatus enumerates the valid statuses for a given purchase order.
type PurchaseOrderStatus int32

const (
	// STATUS_NIL defines a no-op status.
	StatusNil PurchaseOrderStatus = 0
	// STATUS_RAISED defines a raised status.
	StatusRaised PurchaseOrderStatus = 1
	// STATUS_ACCEPTED defines an accepted status.
	StatusAccepted PurchaseOrderStatus = 2
	// STATUS_REJECTED defines a rejected status.
	StatusRejected PurchaseOrderStatus = 3
	// STATUS_COMPLETED defines a completed status.
	StatusCompleted PurchaseOrderStatus = 4
)

var PurchaseOrderStatus_name = map[int32]string{
	0: "STATUS_NIL",
	1: "STATUS_RAISED",
	2: "STATUS_ACCEPTED",
	3: "STATUS_REJECTED",
	4: "STATUS_COMPLETED",
}

var PurchaseOrderStatus_value = map[string]int32{
	"STATUS_NIL":       0,
	"STATUS_RAISED":    1,
	"STATUS_ACCEPTED":  2,
	"STATUS_REJECTED":  3,
	"STATUS_COMPLETED": 4,
}

func (x PurchaseOrderStatus) String() string {
	return proto.EnumName(PurchaseOrderStatus_name, int32(x))
}

func (PurchaseOrderStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0031edbd5eb0f2fc, []int{0}
}

// WhitelistAction enumerates the valid actions for whitelisting addresses.
type WhitelistAction int32

const (
	// WHITELIST_ACTION_NIL defines a no-op action.
	WhitelistActionNil WhitelistAction = 0
	// WHITELIST_ACTION_ADD defines an add action.
	WhitelistActionAdd WhitelistAction = 1
	// WHITELIST_ACTION_REMOVE defines a remove action.
	WhitelistActionRemove WhitelistAction = 2
)

var WhitelistAction_name = map[int32]string{
	0: "WHITELIST_ACTION_NIL",
	1: "WHITELIST_ACTION_ADD",
	2: "WHITELIST_ACTION_REMOVE",
}

var WhitelistAction_value = map[string]int32{
	"WHITELIST_ACTION_NIL":    0,
	"WHITELIST_ACTION_ADD":    1,
	"WHITELIST_ACTION_REMOVE": 2,
}

func (x WhitelistAction) String() string {
	return proto.EnumName(WhitelistAction_name, int32(x))
}

func (WhitelistAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0031edbd5eb0f2fc, []int{1}
}

// PurchaseOrderDecision defines a decision made for a given purchase order, ie,
// whether to accept or reject
type PurchaseOrderDecision struct {
	// signer is an authorised address for making decisions
	Signer string `protobuf:"bytes,1,opt,name=signer,proto3" json:"signer,omitempty"`
	// decision is the decision made, i.e. accept/reject
	Decision PurchaseOrderStatus `protobuf:"varint,2,opt,name=decision,proto3,enum=mainchain.enterprise.v1.PurchaseOrderStatus" json:"decision,omitempty"`
	// decision_time is a unix epoch value of the decision submission time
	DecisionTime uint64 `protobuf:"varint,3,opt,name=decision_time,json=decisionTime,proto3" json:"decision_time,omitempty"`
}

func (m *PurchaseOrderDecision) Reset()         { *m = PurchaseOrderDecision{} }
func (m *PurchaseOrderDecision) String() string { return proto.CompactTextString(m) }
func (*PurchaseOrderDecision) ProtoMessage()    {}
func (*PurchaseOrderDecision) Descriptor() ([]byte, []int) {
	return fileDescriptor_0031edbd5eb0f2fc, []int{0}
}
func (m *PurchaseOrderDecision) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PurchaseOrderDecision) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PurchaseOrderDecision.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PurchaseOrderDecision) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PurchaseOrderDecision.Merge(m, src)
}
func (m *PurchaseOrderDecision) XXX_Size() int {
	return m.Size()
}
func (m *PurchaseOrderDecision) XXX_DiscardUnknown() {
	xxx_messageInfo_PurchaseOrderDecision.DiscardUnknown(m)
}

var xxx_messageInfo_PurchaseOrderDecision proto.InternalMessageInfo

func (m *PurchaseOrderDecision) GetSigner() string {
	if m != nil {
		return m.Signer
	}
	return ""
}

func (m *PurchaseOrderDecision) GetDecision() PurchaseOrderStatus {
	if m != nil {
		return m.Decision
	}
	return StatusNil
}

func (m *PurchaseOrderDecision) GetDecisionTime() uint64 {
	if m != nil {
		return m.DecisionTime
	}
	return 0
}

// EnterpriseUndPurchaseOrder defines a purchase order raised by a whitelisted address
type EnterpriseUndPurchaseOrder struct {
	// id is the purchase order ID
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// purchaser is the address of the user who raised the order
	Purchaser string `protobuf:"bytes,2,opt,name=purchaser,proto3" json:"purchaser,omitempty"`
	// amount is the amount being raised for
	Amount types.Coin `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount"`
	// status is the current PurchaseOrderStatus
	Status PurchaseOrderStatus `protobuf:"varint,4,opt,name=status,proto3,enum=mainchain.enterprise.v1.PurchaseOrderStatus" json:"status,omitempty"`
	// raise_time is a unix epoch value of the order submission time
	RaiseTime uint64 `protobuf:"varint,5,opt,name=raise_time,json=raiseTime,proto3" json:"raise_time,omitempty"`
	// completion_time is a unix epoch value of the time the order was completed
	CompletionTime uint64 `protobuf:"varint,6,opt,name=completion_time,json=completionTime,proto3" json:"completion_time,omitempty"`
	// decisions is an array of decisions made by authorised addresses
	Decisions PurchaseOrderDecisions `protobuf:"bytes,7,rep,name=decisions,proto3,castrepeated=PurchaseOrderDecisions" json:"decisions"`
}

func (m *EnterpriseUndPurchaseOrder) Reset()         { *m = EnterpriseUndPurchaseOrder{} }
func (m *EnterpriseUndPurchaseOrder) String() string { return proto.CompactTextString(m) }
func (*EnterpriseUndPurchaseOrder) ProtoMessage()    {}
func (*EnterpriseUndPurchaseOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_0031edbd5eb0f2fc, []int{1}
}
func (m *EnterpriseUndPurchaseOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnterpriseUndPurchaseOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EnterpriseUndPurchaseOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EnterpriseUndPurchaseOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnterpriseUndPurchaseOrder.Merge(m, src)
}
func (m *EnterpriseUndPurchaseOrder) XXX_Size() int {
	return m.Size()
}
func (m *EnterpriseUndPurchaseOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_EnterpriseUndPurchaseOrder.DiscardUnknown(m)
}

var xxx_messageInfo_EnterpriseUndPurchaseOrder proto.InternalMessageInfo

func (m *EnterpriseUndPurchaseOrder) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *EnterpriseUndPurchaseOrder) GetPurchaser() string {
	if m != nil {
		return m.Purchaser
	}
	return ""
}

func (m *EnterpriseUndPurchaseOrder) GetAmount() types.Coin {
	if m != nil {
		return m.Amount
	}
	return types.Coin{}
}

func (m *EnterpriseUndPurchaseOrder) GetStatus() PurchaseOrderStatus {
	if m != nil {
		return m.Status
	}
	return StatusNil
}

func (m *EnterpriseUndPurchaseOrder) GetRaiseTime() uint64 {
	if m != nil {
		return m.RaiseTime
	}
	return 0
}

func (m *EnterpriseUndPurchaseOrder) GetCompletionTime() uint64 {
	if m != nil {
		return m.CompletionTime
	}
	return 0
}

func (m *EnterpriseUndPurchaseOrder) GetDecisions() PurchaseOrderDecisions {
	if m != nil {
		return m.Decisions
	}
	return nil
}

// PurchaseOrders defines a list of purchase orders
type PurchaseOrders struct {
	PurchaseOrders []*EnterpriseUndPurchaseOrder `protobuf:"bytes,1,rep,name=purchase_orders,json=purchaseOrders,proto3" json:"purchase_orders,omitempty"`
}

func (m *PurchaseOrders) Reset()         { *m = PurchaseOrders{} }
func (m *PurchaseOrders) String() string { return proto.CompactTextString(m) }
func (*PurchaseOrders) ProtoMessage()    {}
func (*PurchaseOrders) Descriptor() ([]byte, []int) {
	return fileDescriptor_0031edbd5eb0f2fc, []int{2}
}
func (m *PurchaseOrders) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PurchaseOrders) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PurchaseOrders.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PurchaseOrders) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PurchaseOrders.Merge(m, src)
}
func (m *PurchaseOrders) XXX_Size() int {
	return m.Size()
}
func (m *PurchaseOrders) XXX_DiscardUnknown() {
	xxx_messageInfo_PurchaseOrders.DiscardUnknown(m)
}

var xxx_messageInfo_PurchaseOrders proto.InternalMessageInfo

func (m *PurchaseOrders) GetPurchaseOrders() []*EnterpriseUndPurchaseOrder {
	if m != nil {
		return m.PurchaseOrders
	}
	return nil
}

// LockedUnd defines the amount of locked FUND for an account
type LockedUnd struct {
	// owner is the address of the locked FUND owner
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	// amount is the amount currently locked and available to pay for beacon/wrkchain fees
	Amount types.Coin `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount"`
}

func (m *LockedUnd) Reset()         { *m = LockedUnd{} }
func (m *LockedUnd) String() string { return proto.CompactTextString(m) }
func (*LockedUnd) ProtoMessage()    {}
func (*LockedUnd) Descriptor() ([]byte, []int) {
	return fileDescriptor_0031edbd5eb0f2fc, []int{3}
}
func (m *LockedUnd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LockedUnd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LockedUnd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LockedUnd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LockedUnd.Merge(m, src)
}
func (m *LockedUnd) XXX_Size() int {
	return m.Size()
}
func (m *LockedUnd) XXX_DiscardUnknown() {
	xxx_messageInfo_LockedUnd.DiscardUnknown(m)
}

var xxx_messageInfo_LockedUnd proto.InternalMessageInfo

func (m *LockedUnd) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *LockedUnd) GetAmount() types.Coin {
	if m != nil {
		return m.Amount
	}
	return types.Coin{}
}

// SpentEFUND defines the amount of spent eFUND for an account
type SpentEFUND struct {
	// owner is the address of the eFUND owner
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	// amount is the amount currently locked and available to pay for beacon/wrkchain fees
	Amount types.Coin `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount"`
}

func (m *SpentEFUND) Reset()         { *m = SpentEFUND{} }
func (m *SpentEFUND) String() string { return proto.CompactTextString(m) }
func (*SpentEFUND) ProtoMessage()    {}
func (*SpentEFUND) Descriptor() ([]byte, []int) {
	return fileDescriptor_0031edbd5eb0f2fc, []int{4}
}
func (m *SpentEFUND) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpentEFUND) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpentEFUND.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpentEFUND) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpentEFUND.Merge(m, src)
}
func (m *SpentEFUND) XXX_Size() int {
	return m.Size()
}
func (m *SpentEFUND) XXX_DiscardUnknown() {
	xxx_messageInfo_SpentEFUND.DiscardUnknown(m)
}

var xxx_messageInfo_SpentEFUND proto.InternalMessageInfo

func (m *SpentEFUND) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *SpentEFUND) GetAmount() types.Coin {
	if m != nil {
		return m.Amount
	}
	return types.Coin{}
}

// EnterpriseUserAccount defines data about an enterprise user
type EnterpriseUserAccount struct {
	// owner is the address of the account
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	// locked_efund is the amount of eFUND the account currently has locked and only available to pay for
	// beacon/wrkchain fees
	LockedEfund types.Coin `protobuf:"bytes,2,opt,name=locked_efund,json=lockedEfund,proto3" json:"locked_efund"`
	// general_supply is the amount currently held in the bank module's supply - i.e. standard FUND in general supply
	// usable for anything (transfers, staking, standard tx fees etc.)
	GeneralSupply types.Coin `protobuf:"bytes,3,opt,name=general_supply,json=generalSupply,proto3" json:"general_supply"`
	// spent_efund is a running tally of how much eFUND the account has used so far to pay for beacon/wrkchain fees
	SpentEfund types.Coin `protobuf:"bytes,4,opt,name=spent_efund,json=spentEfund,proto3" json:"spent_efund"`
	// spendable is the sum of locked eFUND and general bank module FUND - i.e. how much can be used to pay
	// BEACON/Wrkchain fees all together
	Spendable types.Coin `protobuf:"bytes,5,opt,name=spendable,proto3" json:"spendable"`
}

func (m *EnterpriseUserAccount) Reset()         { *m = EnterpriseUserAccount{} }
func (m *EnterpriseUserAccount) String() string { return proto.CompactTextString(m) }
func (*EnterpriseUserAccount) ProtoMessage()    {}
func (*EnterpriseUserAccount) Descriptor() ([]byte, []int) {
	return fileDescriptor_0031edbd5eb0f2fc, []int{5}
}
func (m *EnterpriseUserAccount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnterpriseUserAccount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EnterpriseUserAccount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EnterpriseUserAccount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnterpriseUserAccount.Merge(m, src)
}
func (m *EnterpriseUserAccount) XXX_Size() int {
	return m.Size()
}
func (m *EnterpriseUserAccount) XXX_DiscardUnknown() {
	xxx_messageInfo_EnterpriseUserAccount.DiscardUnknown(m)
}

var xxx_messageInfo_EnterpriseUserAccount proto.InternalMessageInfo

func (m *EnterpriseUserAccount) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *EnterpriseUserAccount) GetLockedEfund() types.Coin {
	if m != nil {
		return m.LockedEfund
	}
	return types.Coin{}
}

func (m *EnterpriseUserAccount) GetGeneralSupply() types.Coin {
	if m != nil {
		return m.GeneralSupply
	}
	return types.Coin{}
}

func (m *EnterpriseUserAccount) GetSpentEfund() types.Coin {
	if m != nil {
		return m.SpentEfund
	}
	return types.Coin{}
}

func (m *EnterpriseUserAccount) GetSpendable() types.Coin {
	if m != nil {
		return m.Spendable
	}
	return types.Coin{}
}

// UndSupply defines the current FUND supply, including locked
type UndSupply struct {
	// denom is the denomination, e.g. nund
	Denom string `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty"`
	// amount is the amount of unlocked FUND in general supply
	Amount uint64 `protobuf:"varint,2,opt,name=amount,proto3" json:"amount,omitempty"`
	// locked is the amount of locked FUND
	Locked uint64 `protobuf:"varint,3,opt,name=locked,proto3" json:"locked,omitempty"`
	// amount is the sum of locked and unlocked FUND
	Total uint64 `protobuf:"varint,4,opt,name=total,proto3" json:"total,omitempty"`
}

func (m *UndSupply) Reset()         { *m = UndSupply{} }
func (m *UndSupply) String() string { return proto.CompactTextString(m) }
func (*UndSupply) ProtoMessage()    {}
func (*UndSupply) Descriptor() ([]byte, []int) {
	return fileDescriptor_0031edbd5eb0f2fc, []int{6}
}
func (m *UndSupply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UndSupply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UndSupply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UndSupply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UndSupply.Merge(m, src)
}
func (m *UndSupply) XXX_Size() int {
	return m.Size()
}
func (m *UndSupply) XXX_DiscardUnknown() {
	xxx_messageInfo_UndSupply.DiscardUnknown(m)
}

var xxx_messageInfo_UndSupply proto.InternalMessageInfo

func (m *UndSupply) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *UndSupply) GetAmount() uint64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *UndSupply) GetLocked() uint64 {
	if m != nil {
		return m.Locked
	}
	return 0
}

func (m *UndSupply) GetTotal() uint64 {
	if m != nil {
		return m.Total
	}
	return 0
}

// WhitelistAddresses defines a list of whitelisted addresses authorised to raise enterprise purchase orders
type WhitelistAddresses struct {
	Addresses []string `protobuf:"bytes,1,rep,name=addresses,proto3" json:"addresses,omitempty"`
}

func (m *WhitelistAddresses) Reset()         { *m = WhitelistAddresses{} }
func (m *WhitelistAddresses) String() string { return proto.CompactTextString(m) }
func (*WhitelistAddresses) ProtoMessage()    {}
func (*WhitelistAddresses) Descriptor() ([]byte, []int) {
	return fileDescriptor_0031edbd5eb0f2fc, []int{7}
}
func (m *WhitelistAddresses) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WhitelistAddresses) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WhitelistAddresses.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WhitelistAddresses) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WhitelistAddresses.Merge(m, src)
}
func (m *WhitelistAddresses) XXX_Size() int {
	return m.Size()
}
func (m *WhitelistAddresses) XXX_DiscardUnknown() {
	xxx_messageInfo_WhitelistAddresses.DiscardUnknown(m)
}

var xxx_messageInfo_WhitelistAddresses proto.InternalMessageInfo

func (m *WhitelistAddresses) GetAddresses() []string {
	if m != nil {
		return m.Addresses
	}
	return nil
}

// Params defines the parameters for the enterprise module.
type Params struct {
	// ent_signers is a list of addresses authorised to make decisions on raised purchase orders
	EntSigners string `protobuf:"bytes,1,opt,name=ent_signers,json=entSigners,proto3" json:"ent_signers,omitempty"`
	// denom is the denomination of eFUND, e.g. nund
	Denom string `protobuf:"bytes,2,opt,name=denom,proto3" json:"denom,omitempty"`
	// min_accepts is the minumum number of ent_signers required to accept a PO before it is processed and efUND minted
	MinAccepts uint64 `protobuf:"varint,3,opt,name=min_accepts,json=minAccepts,proto3" json:"min_accepts,omitempty"`
	// decision_time_limit is the time limit within which all decisions must be made for a raised purchase order.
	DecisionTimeLimit uint64 `protobuf:"varint,4,opt,name=decision_time_limit,json=decisionTimeLimit,proto3" json:"decision_time_limit,omitempty"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_0031edbd5eb0f2fc, []int{8}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetEntSigners() string {
	if m != nil {
		return m.EntSigners
	}
	return ""
}

func (m *Params) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *Params) GetMinAccepts() uint64 {
	if m != nil {
		return m.MinAccepts
	}
	return 0
}

func (m *Params) GetDecisionTimeLimit() uint64 {
	if m != nil {
		return m.DecisionTimeLimit
	}
	return 0
}

func init() {
	proto.RegisterEnum("mainchain.enterprise.v1.PurchaseOrderStatus", PurchaseOrderStatus_name, PurchaseOrderStatus_value)
	proto.RegisterEnum("mainchain.enterprise.v1.WhitelistAction", WhitelistAction_name, WhitelistAction_value)
	proto.RegisterType((*PurchaseOrderDecision)(nil), "mainchain.enterprise.v1.PurchaseOrderDecision")
	proto.RegisterType((*EnterpriseUndPurchaseOrder)(nil), "mainchain.enterprise.v1.EnterpriseUndPurchaseOrder")
	proto.RegisterType((*PurchaseOrders)(nil), "mainchain.enterprise.v1.PurchaseOrders")
	proto.RegisterType((*LockedUnd)(nil), "mainchain.enterprise.v1.LockedUnd")
	proto.RegisterType((*SpentEFUND)(nil), "mainchain.enterprise.v1.SpentEFUND")
	proto.RegisterType((*EnterpriseUserAccount)(nil), "mainchain.enterprise.v1.EnterpriseUserAccount")
	proto.RegisterType((*UndSupply)(nil), "mainchain.enterprise.v1.UndSupply")
	proto.RegisterType((*WhitelistAddresses)(nil), "mainchain.enterprise.v1.WhitelistAddresses")
	proto.RegisterType((*Params)(nil), "mainchain.enterprise.v1.Params")
}

func init() {
	proto.RegisterFile("mainchain/enterprise/v1/enterprise.proto", fileDescriptor_0031edbd5eb0f2fc)
}

var fileDescriptor_0031edbd5eb0f2fc = []byte{
	// 959 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x56, 0x4d, 0x6f, 0x1b, 0x55,
	0x17, 0xf6, 0x38, 0x8e, 0xdf, 0xd7, 0xc7, 0x89, 0x63, 0x6e, 0x3e, 0xea, 0x58, 0xc2, 0x19, 0x99,
	0x05, 0xa1, 0xa2, 0x63, 0x92, 0x4a, 0x74, 0x85, 0x84, 0x63, 0x4f, 0x55, 0x23, 0x37, 0x09, 0x63,
	0x9b, 0x4a, 0x08, 0xc9, 0x1a, 0xcf, 0xdc, 0x3a, 0x17, 0x66, 0xee, 0x8c, 0xe6, 0x5e, 0x07, 0xfa,
	0x0f, 0x90, 0x57, 0xdd, 0xb2, 0xf0, 0x8a, 0x1d, 0x5b, 0x58, 0xf0, 0x13, 0xba, 0xac, 0x10, 0x0b,
	0x16, 0x08, 0x50, 0xf2, 0x47, 0xd0, 0xfd, 0xf0, 0x57, 0x49, 0x2a, 0x97, 0x05, 0x3b, 0x9f, 0x73,
	0x9e, 0xe7, 0xce, 0x73, 0xce, 0x99, 0xfb, 0x78, 0xe0, 0x30, 0x74, 0x09, 0xf5, 0x2e, 0x5c, 0x42,
	0x6b, 0x98, 0x72, 0x9c, 0xc4, 0x09, 0x61, 0xb8, 0x76, 0x79, 0xb4, 0x10, 0x59, 0x71, 0x12, 0xf1,
	0x08, 0xdd, 0x99, 0x21, 0xad, 0x85, 0xda, 0xe5, 0x51, 0xb9, 0xe2, 0x45, 0x2c, 0x8c, 0x58, 0x6d,
	0xe0, 0x4a, 0xe6, 0x00, 0x73, 0xf7, 0xa8, 0xe6, 0x45, 0x84, 0x2a, 0x62, 0x79, 0x5f, 0xd5, 0xfb,
	0x32, 0xaa, 0xa9, 0x40, 0x97, 0x76, 0x86, 0xd1, 0x30, 0x52, 0x79, 0xf1, 0x4b, 0x65, 0xab, 0x3f,
	0x1b, 0xb0, 0x7b, 0x3e, 0x4a, 0xbc, 0x0b, 0x97, 0xe1, 0xb3, 0xc4, 0xc7, 0x49, 0x13, 0x7b, 0x84,
	0x91, 0x88, 0xa2, 0x0f, 0x20, 0xcb, 0xc8, 0x90, 0xe2, 0xa4, 0x64, 0x98, 0xc6, 0x61, 0xee, 0xa4,
	0xf4, 0xcb, 0x4f, 0xf7, 0x76, 0xf4, 0x89, 0x75, 0xdf, 0x4f, 0x30, 0x63, 0x1d, 0x9e, 0x10, 0x3a,
	0x74, 0x34, 0x0e, 0x3d, 0x82, 0xff, 0xfb, 0x9a, 0x5d, 0x4a, 0x9b, 0xc6, 0x61, 0xe1, 0xf8, 0x7d,
	0xeb, 0x96, 0x46, 0xac, 0xa5, 0x67, 0x76, 0xb8, 0xcb, 0x47, 0xcc, 0x99, 0xb1, 0xd1, 0x3b, 0xb0,
	0x39, 0xfd, 0xdd, 0xe7, 0x24, 0xc4, 0xa5, 0x35, 0xd3, 0x38, 0xcc, 0x38, 0x1b, 0xd3, 0x64, 0x97,
	0x84, 0xb8, 0xfa, 0xdd, 0x1a, 0x94, 0xed, 0xd9, 0xa1, 0x3d, 0xea, 0x2f, 0x9d, 0x89, 0x0a, 0x90,
	0x26, 0xbe, 0xd4, 0x9e, 0x71, 0xd2, 0xc4, 0x47, 0x1f, 0x42, 0x2e, 0xd6, 0x80, 0x44, 0xca, 0x7b,
	0x5d, 0x4b, 0x73, 0x28, 0x7a, 0x00, 0x59, 0x37, 0x8c, 0x46, 0x94, 0x4b, 0x11, 0xf9, 0xe3, 0x7d,
	0x4b, 0x33, 0xc4, 0x0e, 0x2c, 0xbd, 0x03, 0xab, 0x11, 0x11, 0x7a, 0x92, 0x79, 0xf1, 0xc7, 0x41,
	0xca, 0xd1, 0x70, 0xd4, 0x84, 0x2c, 0x93, 0x8d, 0x95, 0x32, 0xff, 0x62, 0x18, 0x9a, 0x8b, 0xde,
	0x06, 0x48, 0x5c, 0xc2, 0xb0, 0x9a, 0xc3, 0xba, 0x6c, 0x27, 0x27, 0x33, 0x62, 0x08, 0xe8, 0x5d,
	0xd8, 0xf2, 0xa2, 0x30, 0x0e, 0x30, 0x9f, 0xcd, 0x2a, 0x2b, 0x31, 0x85, 0x79, 0x5a, 0x02, 0x03,
	0xc8, 0x4d, 0xa7, 0xc7, 0x4a, 0xff, 0x33, 0xd7, 0x0e, 0xf3, 0xc7, 0xd6, 0x6a, 0x82, 0xa6, 0x6f,
	0xc4, 0x49, 0x45, 0xb4, 0xf7, 0xc3, 0x9f, 0x07, 0x7b, 0x37, 0x96, 0x99, 0x33, 0x7f, 0x40, 0x95,
	0x42, 0x61, 0x09, 0xc4, 0xd0, 0x17, 0xb0, 0x35, 0x9d, 0x69, 0x3f, 0x92, 0xa9, 0x92, 0x21, 0x55,
	0xdc, 0xbf, 0x55, 0xc5, 0xed, 0xcb, 0x75, 0x0a, 0xf1, 0xd2, 0xe9, 0x55, 0x0e, 0xb9, 0x76, 0xe4,
	0x7d, 0x85, 0xfd, 0x1e, 0xf5, 0x91, 0x05, 0xeb, 0xd1, 0xd7, 0xab, 0xbc, 0xb8, 0x0a, 0xb6, 0xb0,
	0xe1, 0xf4, 0x1b, 0x6d, 0xb8, 0x3a, 0x02, 0xe8, 0xc4, 0x98, 0x72, 0xfb, 0x61, 0xef, 0xb4, 0xf9,
	0xdf, 0x3d, 0xf6, 0xd7, 0x34, 0xec, 0x2e, 0xcc, 0x86, 0xe1, 0xa4, 0xee, 0x79, 0xf2, 0x95, 0x7b,
	0x53, 0x09, 0x27, 0xb0, 0x11, 0xc8, 0xb1, 0xf5, 0xf1, 0xd3, 0x11, 0xf5, 0x57, 0x15, 0x92, 0x57,
	0x24, 0x5b, 0x70, 0xd0, 0x43, 0x28, 0x0c, 0x31, 0xc5, 0x89, 0x1b, 0xf4, 0xd9, 0x28, 0x8e, 0x83,
	0x67, 0xab, 0xde, 0x93, 0x4d, 0x4d, 0xeb, 0x48, 0x16, 0xfa, 0x18, 0xf2, 0x4c, 0x0c, 0x53, 0x4b,
	0xc9, 0xac, 0x76, 0x08, 0x48, 0x8e, 0x52, 0xf2, 0x11, 0xe4, 0x44, 0xe4, 0xbb, 0x83, 0x40, 0xdd,
	0x94, 0x15, 0xf8, 0x73, 0x46, 0x75, 0x08, 0xb9, 0x1e, 0xf5, 0xb5, 0x9a, 0x1d, 0x58, 0xf7, 0x31,
	0x8d, 0x42, 0x35, 0x49, 0x47, 0x05, 0x68, 0x6f, 0x69, 0x65, 0x99, 0xd9, 0x55, 0xdf, 0x83, 0xac,
	0x1a, 0x89, 0x36, 0x2a, 0x1d, 0x89, 0x53, 0x78, 0xc4, 0xdd, 0x40, 0x76, 0x93, 0x71, 0x54, 0x50,
	0x6d, 0x03, 0x7a, 0x72, 0x41, 0x38, 0x0e, 0x08, 0xe3, 0x7a, 0x2d, 0x98, 0x09, 0x7f, 0x72, 0xa7,
	0x81, 0xbc, 0x1a, 0xaf, 0xf5, 0xa7, 0x19, 0xb4, 0xfa, 0xdc, 0x80, 0xec, 0xb9, 0x9b, 0xb8, 0x21,
	0x43, 0x07, 0x90, 0x17, 0x03, 0x54, 0x76, 0xcc, 0xb4, 0x74, 0xc0, 0x94, 0x77, 0x54, 0x66, 0xde,
	0x55, 0x7a, 0xb1, 0xab, 0x03, 0xc8, 0x87, 0x84, 0xf6, 0x5d, 0xcf, 0xc3, 0x31, 0x67, 0xba, 0x05,
	0x08, 0x09, 0xad, 0xab, 0x0c, 0xb2, 0x60, 0x7b, 0xc9, 0x8e, 0xfb, 0x01, 0x09, 0x09, 0xd7, 0x4d,
	0xbd, 0xb5, 0x68, 0xca, 0x6d, 0x51, 0xb8, 0xfb, 0xbb, 0x01, 0xdb, 0x37, 0x78, 0x9a, 0xf0, 0xb2,
	0x4e, 0xb7, 0xde, 0xed, 0x75, 0xfa, 0xa7, 0xad, 0x76, 0x31, 0x55, 0xde, 0x1c, 0x4f, 0xcc, 0x9c,
	0xaa, 0x9d, 0x92, 0x40, 0xb8, 0xbe, 0x2e, 0x3b, 0xf5, 0x56, 0xc7, 0x6e, 0x16, 0x8d, 0x72, 0x71,
	0x3c, 0x31, 0x37, 0xb4, 0x23, 0x0a, 0xcf, 0xf3, 0x85, 0xe1, 0x69, 0x50, 0xbd, 0xd1, 0xb0, 0xcf,
	0xbb, 0x76, 0xb3, 0x98, 0x2e, 0xa3, 0xf1, 0xc4, 0x2c, 0x28, 0x98, 0xd2, 0xbc, 0x04, 0x74, 0xec,
	0x4f, 0xec, 0x86, 0x00, 0xae, 0x2d, 0x02, 0x1d, 0xfc, 0x25, 0xf6, 0x04, 0xf0, 0x3d, 0x28, 0x6a,
	0x60, 0xe3, 0xec, 0xf1, 0x79, 0xdb, 0x16, 0xc8, 0x4c, 0x79, 0x7b, 0x3c, 0x31, 0xb7, 0x14, 0xb2,
	0xa1, 0x9c, 0x14, 0xfb, 0xe5, 0xcc, 0xb7, 0xdf, 0x57, 0x52, 0x77, 0x7f, 0x34, 0x60, 0x6b, 0xbe,
	0x40, 0x8f, 0xab, 0x7f, 0xcb, 0x9d, 0x27, 0x8f, 0x5a, 0x5d, 0xbb, 0xdd, 0xea, 0x74, 0xfb, 0xf5,
	0x46, 0xb7, 0x75, 0x76, 0xaa, 0x9b, 0xdc, 0x1b, 0x4f, 0x4c, 0xf4, 0x0a, 0x5c, 0x74, 0x7b, 0x13,
	0xa3, 0xde, 0x14, 0x4d, 0xdf, 0xc4, 0xa8, 0xfb, 0xe2, 0x1f, 0xec, 0xce, 0x3f, 0x18, 0x8e, 0xfd,
	0xf8, 0xec, 0x33, 0xbb, 0x98, 0x2e, 0xef, 0x8f, 0x27, 0xe6, 0xee, 0x2b, 0x24, 0x07, 0x87, 0xd1,
	0x25, 0x56, 0xaa, 0x4f, 0x3e, 0x7d, 0x71, 0x55, 0x31, 0x5e, 0x5e, 0x55, 0x8c, 0xbf, 0xae, 0x2a,
	0xc6, 0xf3, 0xeb, 0x4a, 0xea, 0xe5, 0x75, 0x25, 0xf5, 0xdb, 0x75, 0x25, 0xf5, 0xf9, 0x83, 0x21,
	0xe1, 0x17, 0xa3, 0x81, 0xe5, 0x45, 0x61, 0x6d, 0x44, 0xc9, 0x53, 0xe2, 0xb9, 0x82, 0x7d, 0x4f,
	0xc4, 0xf3, 0x4f, 0x96, 0x6f, 0x16, 0x3f, 0x5a, 0xf8, 0xb3, 0x18, 0xb3, 0x41, 0x56, 0x7e, 0x43,
	0xdc, 0xff, 0x3b, 0x00, 0x00, 0xff, 0xff, 0xb5, 0x3f, 0xd2, 0x5e, 0xd9, 0x08, 0x00, 0x00,
}

func (m *PurchaseOrderDecision) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PurchaseOrderDecision) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PurchaseOrderDecision) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DecisionTime != 0 {
		i = encodeVarintEnterprise(dAtA, i, uint64(m.DecisionTime))
		i--
		dAtA[i] = 0x18
	}
	if m.Decision != 0 {
		i = encodeVarintEnterprise(dAtA, i, uint64(m.Decision))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Signer) > 0 {
		i -= len(m.Signer)
		copy(dAtA[i:], m.Signer)
		i = encodeVarintEnterprise(dAtA, i, uint64(len(m.Signer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EnterpriseUndPurchaseOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnterpriseUndPurchaseOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EnterpriseUndPurchaseOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Decisions) > 0 {
		for iNdEx := len(m.Decisions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Decisions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEnterprise(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.CompletionTime != 0 {
		i = encodeVarintEnterprise(dAtA, i, uint64(m.CompletionTime))
		i--
		dAtA[i] = 0x30
	}
	if m.RaiseTime != 0 {
		i = encodeVarintEnterprise(dAtA, i, uint64(m.RaiseTime))
		i--
		dAtA[i] = 0x28
	}
	if m.Status != 0 {
		i = encodeVarintEnterprise(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEnterprise(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Purchaser) > 0 {
		i -= len(m.Purchaser)
		copy(dAtA[i:], m.Purchaser)
		i = encodeVarintEnterprise(dAtA, i, uint64(len(m.Purchaser)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintEnterprise(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PurchaseOrders) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PurchaseOrders) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PurchaseOrders) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PurchaseOrders) > 0 {
		for iNdEx := len(m.PurchaseOrders) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PurchaseOrders[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEnterprise(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LockedUnd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LockedUnd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LockedUnd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEnterprise(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintEnterprise(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpentEFUND) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpentEFUND) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpentEFUND) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEnterprise(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintEnterprise(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EnterpriseUserAccount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnterpriseUserAccount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EnterpriseUserAccount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Spendable.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEnterprise(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.SpentEfund.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEnterprise(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.GeneralSupply.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEnterprise(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.LockedEfund.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEnterprise(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintEnterprise(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UndSupply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UndSupply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UndSupply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Total != 0 {
		i = encodeVarintEnterprise(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x20
	}
	if m.Locked != 0 {
		i = encodeVarintEnterprise(dAtA, i, uint64(m.Locked))
		i--
		dAtA[i] = 0x18
	}
	if m.Amount != 0 {
		i = encodeVarintEnterprise(dAtA, i, uint64(m.Amount))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintEnterprise(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WhitelistAddresses) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WhitelistAddresses) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WhitelistAddresses) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Addresses) > 0 {
		for iNdEx := len(m.Addresses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Addresses[iNdEx])
			copy(dAtA[i:], m.Addresses[iNdEx])
			i = encodeVarintEnterprise(dAtA, i, uint64(len(m.Addresses[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DecisionTimeLimit != 0 {
		i = encodeVarintEnterprise(dAtA, i, uint64(m.DecisionTimeLimit))
		i--
		dAtA[i] = 0x20
	}
	if m.MinAccepts != 0 {
		i = encodeVarintEnterprise(dAtA, i, uint64(m.MinAccepts))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintEnterprise(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.EntSigners) > 0 {
		i -= len(m.EntSigners)
		copy(dAtA[i:], m.EntSigners)
		i = encodeVarintEnterprise(dAtA, i, uint64(len(m.EntSigners)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintEnterprise(dAtA []byte, offset int, v uint64) int {
	offset -= sovEnterprise(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *PurchaseOrderDecision) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Signer)
	if l > 0 {
		n += 1 + l + sovEnterprise(uint64(l))
	}
	if m.Decision != 0 {
		n += 1 + sovEnterprise(uint64(m.Decision))
	}
	if m.DecisionTime != 0 {
		n += 1 + sovEnterprise(uint64(m.DecisionTime))
	}
	return n
}

func (m *EnterpriseUndPurchaseOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovEnterprise(uint64(m.Id))
	}
	l = len(m.Purchaser)
	if l > 0 {
		n += 1 + l + sovEnterprise(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovEnterprise(uint64(l))
	if m.Status != 0 {
		n += 1 + sovEnterprise(uint64(m.Status))
	}
	if m.RaiseTime != 0 {
		n += 1 + sovEnterprise(uint64(m.RaiseTime))
	}
	if m.CompletionTime != 0 {
		n += 1 + sovEnterprise(uint64(m.CompletionTime))
	}
	if len(m.Decisions) > 0 {
		for _, e := range m.Decisions {
			l = e.Size()
			n += 1 + l + sovEnterprise(uint64(l))
		}
	}
	return n
}

func (m *PurchaseOrders) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PurchaseOrders) > 0 {
		for _, e := range m.PurchaseOrders {
			l = e.Size()
			n += 1 + l + sovEnterprise(uint64(l))
		}
	}
	return n
}

func (m *LockedUnd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovEnterprise(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovEnterprise(uint64(l))
	return n
}

func (m *SpentEFUND) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovEnterprise(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovEnterprise(uint64(l))
	return n
}

func (m *EnterpriseUserAccount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovEnterprise(uint64(l))
	}
	l = m.LockedEfund.Size()
	n += 1 + l + sovEnterprise(uint64(l))
	l = m.GeneralSupply.Size()
	n += 1 + l + sovEnterprise(uint64(l))
	l = m.SpentEfund.Size()
	n += 1 + l + sovEnterprise(uint64(l))
	l = m.Spendable.Size()
	n += 1 + l + sovEnterprise(uint64(l))
	return n
}

func (m *UndSupply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovEnterprise(uint64(l))
	}
	if m.Amount != 0 {
		n += 1 + sovEnterprise(uint64(m.Amount))
	}
	if m.Locked != 0 {
		n += 1 + sovEnterprise(uint64(m.Locked))
	}
	if m.Total != 0 {
		n += 1 + sovEnterprise(uint64(m.Total))
	}
	return n
}

func (m *WhitelistAddresses) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Addresses) > 0 {
		for _, s := range m.Addresses {
			l = len(s)
			n += 1 + l + sovEnterprise(uint64(l))
		}
	}
	return n
}

func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EntSigners)
	if l > 0 {
		n += 1 + l + sovEnterprise(uint64(l))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovEnterprise(uint64(l))
	}
	if m.MinAccepts != 0 {
		n += 1 + sovEnterprise(uint64(m.MinAccepts))
	}
	if m.DecisionTimeLimit != 0 {
		n += 1 + sovEnterprise(uint64(m.DecisionTimeLimit))
	}
	return n
}

func sovEnterprise(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEnterprise(x uint64) (n int) {
	return sovEnterprise(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PurchaseOrderDecision) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnterprise
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PurchaseOrderDecision: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PurchaseOrderDecision: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnterprise
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnterprise
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnterprise
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decision", wireType)
			}
			m.Decision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnterprise
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Decision |= PurchaseOrderStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecisionTime", wireType)
			}
			m.DecisionTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnterprise
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DecisionTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEnterprise(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnterprise
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnterpriseUndPurchaseOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnterprise
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnterpriseUndPurchaseOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnterpriseUndPurchaseOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnterprise
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Purchaser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnterprise
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnterprise
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnterprise
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Purchaser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnterprise
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnterprise
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnterprise
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnterprise
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= PurchaseOrderStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaiseTime", wireType)
			}
			m.RaiseTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnterprise
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RaiseTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletionTime", wireType)
			}
			m.CompletionTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnterprise
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompletionTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decisions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnterprise
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnterprise
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnterprise
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Decisions = append(m.Decisions, PurchaseOrderDecision{})
			if err := m.Decisions[len(m.Decisions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnterprise(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnterprise
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PurchaseOrders) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnterprise
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PurchaseOrders: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PurchaseOrders: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PurchaseOrders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnterprise
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnterprise
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnterprise
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PurchaseOrders = append(m.PurchaseOrders, &EnterpriseUndPurchaseOrder{})
			if err := m.PurchaseOrders[len(m.PurchaseOrders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnterprise(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnterprise
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LockedUnd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnterprise
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LockedUnd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LockedUnd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnterprise
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnterprise
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnterprise
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnterprise
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnterprise
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnterprise
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnterprise(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnterprise
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpentEFUND) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnterprise
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpentEFUND: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpentEFUND: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnterprise
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnterprise
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnterprise
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnterprise
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnterprise
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnterprise
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnterprise(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnterprise
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnterpriseUserAccount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnterprise
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnterpriseUserAccount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnterpriseUserAccount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnterprise
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnterprise
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnterprise
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockedEfund", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnterprise
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnterprise
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnterprise
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LockedEfund.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeneralSupply", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnterprise
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnterprise
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnterprise
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GeneralSupply.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpentEfund", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnterprise
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnterprise
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnterprise
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SpentEfund.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spendable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnterprise
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnterprise
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnterprise
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spendable.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnterprise(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnterprise
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UndSupply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnterprise
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UndSupply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UndSupply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnterprise
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnterprise
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnterprise
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnterprise
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locked", wireType)
			}
			m.Locked = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnterprise
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Locked |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnterprise
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEnterprise(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnterprise
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WhitelistAddresses) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnterprise
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WhitelistAddresses: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WhitelistAddresses: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnterprise
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnterprise
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnterprise
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addresses = append(m.Addresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnterprise(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnterprise
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnterprise
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntSigners", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnterprise
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnterprise
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnterprise
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntSigners = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnterprise
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnterprise
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnterprise
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinAccepts", wireType)
			}
			m.MinAccepts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnterprise
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinAccepts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecisionTimeLimit", wireType)
			}
			m.DecisionTimeLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnterprise
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DecisionTimeLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEnterprise(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnterprise
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEnterprise(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEnterprise
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEnterprise
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEnterprise
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEnterprise
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEnterprise
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEnterprise
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEnterprise        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEnterprise          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEnterprise = fmt.Errorf("proto: unexpected end of group")
)
