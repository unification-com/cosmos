package test_helpers

//import (
//	"bytes"
//	"encoding/json"
//	"fmt"
//	"math/rand"
//	"os"
//	"path/filepath"
//	"strconv"
//	"testing"
//	"time"
//
//	codectypes "github.com/cosmos/cosmos-sdk/codec/types"
//	cryptocodec "github.com/cosmos/cosmos-sdk/crypto/codec"
//	"github.com/cosmos/cosmos-sdk/crypto/keys/secp256k1"
//	authtypes "github.com/cosmos/cosmos-sdk/x/auth/types"
//	banktypes "github.com/cosmos/cosmos-sdk/x/bank/types"
//	crisistypes "github.com/cosmos/cosmos-sdk/x/crisis/types"
//	govtypes "github.com/cosmos/cosmos-sdk/x/gov/types"
//	govtypesv1 "github.com/cosmos/cosmos-sdk/x/gov/types/v1"
//	stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"
//	"github.com/stretchr/testify/require"
//
//	"github.com/cosmos/cosmos-sdk/codec"
//	"github.com/cosmos/cosmos-sdk/testutil/mock"
//	"github.com/cosmos/cosmos-sdk/types/simulation"
//	"github.com/cosmos/cosmos-sdk/types/tx/signing"
//	"github.com/unification-com/mainchain/app/params"
//
//	dbm "github.com/cometbft/cometbft-db"
//	abci "github.com/cometbft/cometbft/abci/types"
//	"github.com/cometbft/cometbft/libs/log"
//	tmproto "github.com/cometbft/cometbft/proto/tendermint/types"
//	tmtypes "github.com/cometbft/cometbft/types"
//	authsign "github.com/cosmos/cosmos-sdk/x/auth/signing"
//
//	"github.com/cosmos/cosmos-sdk/client"
//	"github.com/cosmos/cosmos-sdk/crypto/keys/ed25519"
//	cryptotypes "github.com/cosmos/cosmos-sdk/crypto/types"
//	sdk "github.com/cosmos/cosmos-sdk/types"
//	beacontypes "github.com/unification-com/mainchain/x/beacon/types"
//	enttypes "github.com/unification-com/mainchain/x/enterprise/types"
//	wrkchaintypes "github.com/unification-com/mainchain/x/wrkchain/types"
//
//	"github.com/unification-com/mainchain/app"
//)
//
//// SimAppChainID hardcoded chainID for simulation
//const (
//	TestDenomination   = "nund"
//	SimAppChainID      = "simulation-app"
//	charset            = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ123456789"
//	TestDefaultStorage = 200
//	TestMaxStorage     = 300
//)
//
//// DefaultConsensusParams defines the default Tendermint consensus params used in
//// app.App testing.
//var (
//	DefaultConsensusParams = &abci.ConsensusParams{
//		Block: &abci.BlockParams{
//			MaxBytes: 200000,
//			MaxGas:   2000000,
//		},
//		Evidence: &tmproto.EvidenceParams{
//			MaxAgeNumBlocks: 302400,
//			MaxAgeDuration:  504 * time.Hour, // 3 weeks is the max duration
//			MaxBytes:        10000,
//		},
//		Validator: &tmproto.ValidatorParams{
//			PubKeyTypes: []string{
//				tmtypes.ABCIPubKeyTypeEd25519,
//			},
//		},
//	}
//	EncodingConfig = params.EncodingConfig{}
//	seededRand     = rand.New(rand.NewSource(time.Now().UnixNano()))
//)
//
//func setupSdkConfig() {
//	config := sdk.GetConfig()
//	if config.GetBech32AccountAddrPrefix() == "cosmos" {
//		app.SetConfig()
//	}
//}
//
//func setup(withGenesis bool, invCheckPeriod uint) (*app.App, app.GenesisState) {
//	db := dbm.NewMemDB()
//	userHomeDir, err := os.UserHomeDir()
//	if err != nil {
//		panic(err)
//	}
//	nodeHome := filepath.Join(userHomeDir, ".und_testapp")
//
//	setupSdkConfig()
//
//	encCdc := GetAppEncodingConfig()
//
//	testApp := app.NewApp(log.NewNopLogger(), db, nil, true, map[int64]bool{}, nodeHome, invCheckPeriod, encCdc, EmptyAppOptions{})
//	if withGenesis {
//		return testApp, NewDefaultGenesisState(encCdc.Codec)
//	}
//	return testApp, app.GenesisState{}
//}
//
//func GetAppEncodingConfig() params.EncodingConfig {
//	return app.MakeEncodingConfig()
//}
//
//// Setup initializes a new app.App. A Nop logger is set in app.App.
//func Setup(t *testing.T, isCheckTx bool) *app.App {
//	t.Helper()
//
//	setupSdkConfig()
//
//	privVal := mock.NewPV()
//	pubKey, err := privVal.GetPubKey()
//	require.NoError(t, err)
//
//	// create validator set with single validator
//	validator := tmtypes.NewValidator(pubKey, 1)
//	valSet := tmtypes.NewValidatorSet([]*tmtypes.Validator{validator})
//
//	// generate genesis account
//	senderPrivKey := secp256k1.GenPrivKey()
//	acc := authtypes.NewBaseAccount(senderPrivKey.PubKey().Address().Bytes(), senderPrivKey.PubKey(), 0, 0)
//	balance := banktypes.Balance{
//		Address: acc.GetAddress().String(),
//		Coins:   sdk.NewCoins(sdk.NewCoin(TestDenomination, sdk.NewInt(100000000000000))),
//	}
//
//	app := SetupWithGenesisValSet(t, valSet, []authtypes.GenesisAccount{acc}, balance)
//
//	return app
//}
//
//func genesisStateWithValSet(t *testing.T,
//	app *app.App, genesisState app.GenesisState,
//	valSet *tmtypes.ValidatorSet, genAccs []authtypes.GenesisAccount,
//	balances ...banktypes.Balance,
//) app.GenesisState {
//	// set genesis accounts
//	authGenesis := authtypes.NewGenesisState(authtypes.DefaultParams(), genAccs)
//	genesisState[authtypes.ModuleName] = app.AppCodec().MustMarshalJSON(authGenesis)
//
//	validators := make([]stakingtypes.Validator, 0, len(valSet.Validators))
//	delegations := make([]stakingtypes.Delegation, 0, len(valSet.Validators))
//
//	bondAmt := sdk.DefaultPowerReduction
//
//	for _, val := range valSet.Validators {
//		pk, err := cryptocodec.FromTmPubKeyInterface(val.PubKey)
//		require.NoError(t, err)
//		pkAny, err := codectypes.NewAnyWithValue(pk)
//		require.NoError(t, err)
//		validator := stakingtypes.Validator{
//			OperatorAddress:   sdk.ValAddress(val.Address).String(),
//			ConsensusPubkey:   pkAny,
//			Jailed:            false,
//			Status:            stakingtypes.Bonded,
//			Tokens:            bondAmt,
//			DelegatorShares:   sdk.OneDec(),
//			Description:       stakingtypes.Description{},
//			UnbondingHeight:   int64(0),
//			UnbondingTime:     time.Unix(0, 0).UTC(),
//			Commission:        stakingtypes.NewCommission(sdk.ZeroDec(), sdk.ZeroDec(), sdk.ZeroDec()),
//			MinSelfDelegation: sdk.ZeroInt(),
//		}
//		validators = append(validators, validator)
//		delegations = append(delegations, stakingtypes.NewDelegation(genAccs[0].GetAddress(), val.Address.Bytes(), sdk.OneDec()))
//
//	}
//	// set validators and delegations
//	stakingParams := stakingtypes.DefaultParams()
//	stakingParams.BondDenom = TestDenomination
//	stakingGenesis := stakingtypes.NewGenesisState(stakingParams, validators, delegations)
//	genesisState[stakingtypes.ModuleName] = app.AppCodec().MustMarshalJSON(stakingGenesis)
//
//	totalSupply := sdk.NewCoins()
//	for _, b := range balances {
//		// add genesis acc tokens to total supply
//		totalSupply = totalSupply.Add(b.Coins...)
//	}
//
//	for range delegations {
//		// add delegated tokens to total supply
//		totalSupply = totalSupply.Add(sdk.NewCoin(TestDenomination, bondAmt))
//	}
//
//	// add bonded amount to bonded pool module account
//	balances = append(balances, banktypes.Balance{
//		Address: authtypes.NewModuleAddress(stakingtypes.BondedPoolName).String(),
//		Coins:   sdk.Coins{sdk.NewCoin(TestDenomination, bondAmt)},
//	})
//
//	// update total supply
//	bankGenesis := banktypes.NewGenesisState(banktypes.DefaultGenesisState().Params, balances, totalSupply, []banktypes.Metadata{})
//	genesisState[banktypes.ModuleName] = app.AppCodec().MustMarshalJSON(bankGenesis)
//
//	govGenesis := govtypesv1.DefaultGenesisState()
//	govGenesis.DepositParams.MinDeposit = sdk.Coins{sdk.NewCoin(TestDenomination, sdk.NewIntFromUint64(10000000))}
//	genesisState[govtypes.ModuleName] = app.AppCodec().MustMarshalJSON(govGenesis)
//
//	crisisGenesis := crisistypes.NewGenesisState(sdk.NewCoin(TestDenomination, sdk.NewIntFromUint64(1000)))
//	genesisState[crisistypes.ModuleName] = app.AppCodec().MustMarshalJSON(crisisGenesis)
//
//	return genesisState
//}
//
//// SetupWithGenesisValSet initializes a new SimApp with a validator set and genesis accounts
//// that also act as delegators. For simplicity, each validator is bonded with a delegation
//// of one consensus engine unit in the default token of the simapp from first genesis
//// account. A Nop logger is set in SimApp.
//func SetupWithGenesisValSet(t *testing.T, valSet *tmtypes.ValidatorSet, genAccs []authtypes.GenesisAccount, balances ...banktypes.Balance) *app.App {
//	t.Helper()
//
//	app, genesisState := setup(true, 5)
//	genesisState = genesisStateWithValSet(t, app, genesisState, valSet, genAccs, balances...)
//
//	stateBytes, err := json.MarshalIndent(genesisState, "", " ")
//	require.NoError(t, err)
//
//	//if t.Name() == "TestKeeperTestSuite/TestGRPCQueryTotalSupply" {
//	//	fmt.Println("--------------------")
//	//	s := string(stateBytes)
//	//	fmt.Println(s)
//	//	fmt.Println("--------------------")
//	//}
//
//	// init chain will set the validator set and initialize the genesis accounts
//	app.InitChain(
//		abci.RequestInitChain{
//			Validators:      []abci.ValidatorUpdate{},
//			ConsensusParams: DefaultConsensusParams,
//			AppStateBytes:   stateBytes,
//		},
//	)
//
//	// commit genesis changes
//	app.Commit()
//	app.BeginBlock(abci.RequestBeginBlock{Header: tmproto.Header{
//		Height:             app.LastBlockHeight() + 1,
//		AppHash:            app.LastCommitID().Hash,
//		ValidatorsHash:     valSet.Hash(),
//		NextValidatorsHash: valSet.Hash(),
//	}})
//
//	return app
//}
//
//func SetKeeperTestParamsAndDefaultValues(app *app.App, ctx sdk.Context) {
//	app.BeaconKeeper.SetParams(ctx, beacontypes.NewParams(24, 2, 2, TestDenomination, TestDefaultStorage, TestMaxStorage))
//	app.WrkchainKeeper.SetParams(ctx, wrkchaintypes.NewParams(24, 2, 2, TestDenomination, TestDefaultStorage, TestMaxStorage))
//	app.EnterpriseKeeper.SetParams(ctx, enttypes.Params{
//		EntSigners:        sdk.AccAddress(ed25519.GenPrivKey().PubKey().Address()).String(),
//		Denom:             TestDenomination,
//		MinAccepts:        1,
//		DecisionTimeLimit: 1000,
//	})
//	_ = app.EnterpriseKeeper.SetTotalLockedUnd(ctx, sdk.NewInt64Coin(TestDenomination, 0))
//	_ = app.EnterpriseKeeper.SetTotalSpentEFUND(ctx, sdk.NewInt64Coin(TestDenomination, 0))
//	app.EnterpriseKeeper.SetHighestPurchaseOrderID(ctx, 1)
//}
//
//type GenerateAccountStrategy func(int) []sdk.AccAddress
//
//// createRandomAccounts is a strategy used by addTestAddrs() in order to generated addresses in random order.
//func createRandomAccounts(accNum int) []sdk.AccAddress {
//	testAddrs := make([]sdk.AccAddress, accNum)
//	for i := 0; i < accNum; i++ {
//		pk := ed25519.GenPrivKey().PubKey()
//		testAddrs[i] = sdk.AccAddress(pk.Address())
//	}
//
//	return testAddrs
//}
//
//func GenerateRandomTestAccounts(accNum int) []sdk.AccAddress {
//	return createRandomAccounts(accNum)
//}
//
//func GenerateRandomStringWithCharset(length int, charset string) string {
//	b := make([]byte, length)
//	for i := range b {
//		b[i] = charset[seededRand.Intn(len(charset))]
//	}
//	return string(b)
//}
//
//// GenerateRandomString generates a random string given a length, based on a set character set
//func GenerateRandomString(length int) string {
//	return GenerateRandomStringWithCharset(length, charset)
//}
//
//func RandInBetween(min, max int) int {
//	return rand.Intn(max-min) + min
//}
//
//// createIncrementalAccounts is a strategy used by addTestAddrs() in order to generated addresses in ascending order.
//func createIncrementalAccounts(accNum int) []sdk.AccAddress {
//	var addresses []sdk.AccAddress
//	var buffer bytes.Buffer
//
//	// start at 100 so we can make up to 999 test addresses with valid test addresses
//	for i := 100; i < (accNum + 100); i++ {
//		numString := strconv.Itoa(i)
//		buffer.WriteString("A58856F0FD53BF058B4909A21AEC019107BA6") //base address string
//
//		buffer.WriteString(numString) //adding on final two digits to make addresses unique
//		res, _ := sdk.AccAddressFromHexUnsafe(buffer.String())
//		bech := res.String()
//		addr, _ := TestAddr(buffer.String(), bech)
//
//		addresses = append(addresses, addr)
//		buffer.Reset()
//	}
//
//	return addresses
//}
//
//func fundAccount(app *app.App, ctx sdk.Context, addr sdk.AccAddress, amtCoins sdk.Coins) error {
//	err := app.BankKeeper.MintCoins(ctx, enttypes.ModuleName, amtCoins)
//	if err != nil {
//		return err
//	}
//	err = app.BankKeeper.SendCoinsFromModuleToAccount(ctx, enttypes.ModuleName, addr, amtCoins)
//	if err != nil {
//		return err
//	}
//	return nil
//}
//
//// AddTestAddrs constructs and returns accNum amount of accounts with an
//// initial balance of accAmt in random order
//func AddTestAddrs(app *app.App, ctx sdk.Context, accNum int, accAmt sdk.Int) []sdk.AccAddress {
//	return addTestAddrs(app, ctx, accNum, accAmt, createRandomAccounts)
//}
//
//// AddTestAddrs constructs and returns accNum amount of accounts with an
//// initial balance of accAmt in random order
//func AddTestAddrsIncremental(app *app.App, ctx sdk.Context, accNum int, accAmt sdk.Int) []sdk.AccAddress {
//	return addTestAddrs(app, ctx, accNum, accAmt, createIncrementalAccounts)
//}
//
//func addTestAddrs(app *app.App, ctx sdk.Context, accNum int, accAmt sdk.Int, strategy GenerateAccountStrategy) []sdk.AccAddress {
//	testAddrs := strategy(accNum)
//
//	initCoins := sdk.NewCoins(sdk.NewCoin(app.StakingKeeper.BondDenom(ctx), accAmt))
//
//	// fill all the addresses with some coins, set the loose pool tokens simultaneously
//	for _, addr := range testAddrs {
//		saveAccount(app, ctx, addr, initCoins)
//	}
//
//	return testAddrs
//}
//
//// saveAccount saves the provided account into the app.App with balance based on initCoins.
//func saveAccount(app *app.App, ctx sdk.Context, addr sdk.AccAddress, initCoins sdk.Coins) {
//	acc := app.AccountKeeper.NewAccountWithAddress(ctx, addr)
//	app.AccountKeeper.SetAccount(ctx, acc)
//	err := fundAccount(app, ctx, addr, initCoins)
//	if err != nil {
//		panic(err)
//	}
//}
//
//func TestAddr(addr string, bech string) (sdk.AccAddress, error) {
//	res, err := sdk.AccAddressFromHexUnsafe(addr)
//	if err != nil {
//		return nil, err
//	}
//	bechexpected := res.String()
//	if bech != bechexpected {
//		return nil, fmt.Errorf("bech encoding doesn't match reference")
//	}
//
//	bechres, err := sdk.AccAddressFromBech32(bech)
//	if err != nil {
//		return nil, err
//	}
//	if !bytes.Equal(bechres, res) {
//		return nil, err
//	}
//
//	return res, nil
//}
//
//// EmptyAppOptions is a stub implementing AppOptions
//type EmptyAppOptions struct{}
//
//// Get implements AppOptions
//func (ao EmptyAppOptions) Get(o string) interface{} {
//	return nil
//}
//
//// NewDefaultGenesisState generates the default state for the application.
//func NewDefaultGenesisState(cdc codec.JSONCodec) app.GenesisState {
//	return app.ModuleBasics.DefaultGenesis(cdc)
//}
//
//// GenSignedMockTx generates a signed mock transaction.
//func GenSignedMockTx(r *rand.Rand, txConfig client.TxConfig, msgs []sdk.Msg, feeAmt sdk.Coins, gas uint64, chainID string, accNums, accSeqs []uint64, priv ...cryptotypes.PrivKey) (sdk.Tx, error) {
//	sigs := make([]signing.SignatureV2, len(priv))
//
//	// create a random length memo
//	memo := simulation.RandStringOfLength(r, simulation.RandIntBetween(r, 0, 100))
//
//	signMode := txConfig.SignModeHandler().DefaultMode()
//
//	// 1st round: set SignatureV2 with empty signatures, to set correct
//	// signer infos.
//	for i, p := range priv {
//		sigs[i] = signing.SignatureV2{
//			PubKey: p.PubKey(),
//			Data: &signing.SingleSignatureData{
//				SignMode: signMode,
//			},
//			Sequence: accSeqs[i],
//		}
//	}
//
//	tx := txConfig.NewTxBuilder()
//	err := tx.SetMsgs(msgs...)
//	if err != nil {
//		return nil, err
//	}
//	err = tx.SetSignatures(sigs...)
//	if err != nil {
//		return nil, err
//	}
//	tx.SetMemo(memo)
//	tx.SetFeeAmount(feeAmt)
//	tx.SetGasLimit(gas)
//
//	// 2nd round: once all signer infos are set, every signer can sign.
//	for i, p := range priv {
//		signerData := authsign.SignerData{
//			Address:       sdk.AccAddress(p.PubKey().Address()).String(),
//			ChainID:       chainID,
//			AccountNumber: accNums[i],
//			Sequence:      accSeqs[i],
//			PubKey:        p.PubKey(),
//		}
//		signBytes, err := txConfig.SignModeHandler().GetSignBytes(signMode, signerData, tx.GetTx())
//		if err != nil {
//			panic(err)
//		}
//		sig, err := p.Sign(signBytes)
//		if err != nil {
//			panic(err)
//		}
//		sigs[i].Data.(*signing.SingleSignatureData).Signature = sig
//		err = tx.SetSignatures(sigs...)
//		if err != nil {
//			panic(err)
//		}
//	}
//
//	return tx.GetTx(), nil
//}
//
//// GenTx generates a signed mock transaction.
//func GenTx(gen client.TxConfig, msgs []sdk.Msg, feeAmt sdk.Coins, gas uint64, chainID string, accNums, accSeqs []uint64, priv ...cryptotypes.PrivKey) (sdk.Tx, error) {
//	sigs := make([]signing.SignatureV2, len(priv))
//
//	// create a random length memo
//	r := rand.New(rand.NewSource(time.Now().UnixNano()))
//
//	memo := simulation.RandStringOfLength(r, simulation.RandIntBetween(r, 0, 100))
//
//	signMode := gen.SignModeHandler().DefaultMode()
//
//	// 1st round: set SignatureV2 with empty signatures, to set correct
//	// signer infos.
//	for i, p := range priv {
//		sigs[i] = signing.SignatureV2{
//			PubKey: p.PubKey(),
//			Data: &signing.SingleSignatureData{
//				SignMode: signMode,
//			},
//			Sequence: accSeqs[i],
//		}
//	}
//
//	tx := gen.NewTxBuilder()
//	err := tx.SetMsgs(msgs...)
//	if err != nil {
//		return nil, err
//	}
//	err = tx.SetSignatures(sigs...)
//	if err != nil {
//		return nil, err
//	}
//	tx.SetMemo(memo)
//	tx.SetFeeAmount(feeAmt)
//	tx.SetGasLimit(gas)
//
//	// 2nd round: once all signer infos are set, every signer can sign.
//	for i, p := range priv {
//		signerData := authsign.SignerData{
//			ChainID:       chainID,
//			AccountNumber: accNums[i],
//			Sequence:      accSeqs[i],
//		}
//		signBytes, err := gen.SignModeHandler().GetSignBytes(signMode, signerData, tx.GetTx())
//		if err != nil {
//			panic(err)
//		}
//		sig, err := p.Sign(signBytes)
//		if err != nil {
//			panic(err)
//		}
//		sigs[i].Data.(*signing.SingleSignatureData).Signature = sig
//		err = tx.SetSignatures(sigs...)
//		if err != nil {
//			panic(err)
//		}
//	}
//
//	return tx.GetTx(), nil
//}
